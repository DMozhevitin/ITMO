# A. Простое двоичное дерево поиска

Реализуйте просто двоичное дерево поиска.

**Входные данные**

Входной файл содержит описание операций с деревом, их количество не превышает 100. В каждой строке находится одна из следующих операций:

insert x — добавить в дерево ключ x. Если ключ x есть в дереве, то ничего делать не надо
delete x — удалить из дерева ключ x. Если ключа x в дереве нет, то ничего делать не надо
exists x — если ключ x есть в дереве выведите «true», если нет «false»
next x — выведите минимальный элемент в дереве, строго больший x, или «none» если такого нет
prev x — выведите максимальный элемент в дереве, строго меньший x, или «none» если такого нет
В дерево помещаются и извлекаются только целые числа, не превышающие по модулю 109.

**Выходные данные**

Выведите последовательно результат выполнения всех операций exists, next, prev. Следуйте формату выходного файла из примера.

# B. Сбалансированное двоичное дерево поиска

Реализуйте сбалансированное двоичное дерево поиска.

**Входные данные**

Входной файл содержит описание операций с деревом, их количество не превышает 105. В каждой строке находится одна из следующих операций:

insert x — добавить в дерево ключ x. Если ключ x есть в дереве, то ничего делать не надо
delete x — удалить из дерева ключ x. Если ключа x в дереве нет, то ничего делать не надо
exists x — если ключ x есть в дереве выведите «true», если нет «false»
next x — выведите минимальный элемент в дереве, строго больший x, или «none» если такого нет
prev x — выведите максимальный элемент в дереве, строго меньший x, или «none» если такого нет
В дерево помещаются и извлекаются только целые числа, не превышающие по модулю 109.

**Выходные данные**

Выведите последовательно результат выполнения всех операций exists, next, prev. Следуйте формату выходного файла из примера.

# C. Декартово дерево

Вам даны пары чисел (ai, bi). Необходимо построить декартово дерево, такое что i-я вершина имеет ключи (ai, bi), вершины с ключом ai образуют бинарное дерево поиска, а вершины с ключом bi образуют кучу.

**Входные данные**

В первой строке записано число N — количество пар. Далее следует N (1 ≤ N ≤ 300 000) пар (ai, bi). Для всех пар |ai|, |bi| ≤ 1 000 000. ai ≠ aj и bi ≠ bj для всех i ≠ j.

**Выходные данные**

Если декартово дерево с таким набором ключей построить возможно, выведите в первой строке «YES», в противном случае выведите «NO». В случае ответа «YES» выведите N строк, каждая из которых должна описывать вершину. Описание вершины состоит из трёх чисел: номера предка, номера левого сына и номера правого сына. Если у вершины отсутствует предок или какой либо из сыновей, выведите на его месте число 0.

Если подходящих деревьев несколько, выведите любое.

# D. Добавление ключей

Вы работаете в компании Макрохард и вас попросили реализовать структуру данных, которая
будет хранить множество целых ключей.
Будем считать, что ключи хранятся в бесконечном массиве A, проиндексированном с 1, исходно
все его ячейки пусты. Структура данных должна поддерживать следующую операцию:
Insert(L, K), где L — позиция в массиве, а K — некоторое положительное целое число.
Операция должна выполняться следующим образом:
• Если ячейка A[L] пуста, присвоить A[L] ← K.
• Если A[L] непуста, выполнить Insert(L + 1, A[L]) и затем присвоить A[L] ← K.
По заданным N целым числам L1, L2, . . . , LN выведите массив после выполнения последовательности операций:
Insert(L1, 1)
Insert(L2, 2)
. . .
Insert(LN , N)

**Формат входных данных**

Первая строка входного файла содержит числа N — количество операций Insert, которое
следует выполнить и M — максимальную позицию, которая используется в операциях Insert
(1 ⩽ N ⩽ 131 072, 1 ⩽ M ⩽ 131 072).
Следующая строка содержит N целых чисел Li
, которые описывают операции Insert, которые
следует выполнить (1 ⩽ Li ⩽ M).

**Формат выходных данных**

Выведите содержимое массива после выполнения всех сделанных операций Insert. На первой
строке выведите W — номер максимальной непустой ячейки в массиве. Затем выведите W целых
чисел — A[1], A[2], . . . , A[W]. Выводите нули для пустых ячеек.

# E. И снова сумма

Реализуйте структуру данных, которая поддерживает множество S целых чисел, с котором разрешается производить следующие операции:

 — добавить в множество S число i (если он там уже есть, то множество не меняется);
 — вывести сумму всех элементов x из S, которые удовлетворяют неравенству l ≤ x ≤ r.
 
**Входные данные**

Исходно множество S пусто. Первая строка входного файла содержит n — количество операций (1 ≤ n ≤ 300 000).Следующие n строк содержат операции. Каждая операция имеет вид либо «+ i», либо «? l r». Операция «? l r» задает запрос .

Если операция «+ i» идет во входном файле в начале или после другой операции «+», то она задает операцию . Если же она идет после запроса «?», и результат этого запроса был y, то выполняется операция .

Во всех запросах и операциях добавления параметры лежат в интервале от 0 до 109.

**Выходные данные**

Для каждого запроса выведите одно число — ответ на запрос.

# K-й максимум

Напишите программу, реализующую структуру данных, позволяющую добавлять и удалять элементы, а также находить k-й максимум.

**Входные данные**

Первая строка входного файла содержит натуральное число n — количество команд (n ≤ 100 000). Последующие n строк содержат по одной команде каждая. Команда записывается в виде двух чисел ci и ki — тип и аргумент команды соответственно (|ki| ≤ 109). Поддерживаемые команды:

+1 (или просто 1): Добавить элемент с ключом ki.
 0: Найти и вывести ki-й максимум.
-1: Удалить элемент с ключом ki.
Гарантируется, что в процессе работы в структуре не требуется хранить элементы с равными ключами или удалять несуществующие элементы. Также гарантируется, что при запросе ki-го максимума, он существует.

**Выходные данные**

Для каждой команды нулевого типа в выходной файл должна быть выведена строка, содержащая единственное число — ki-й максимум.

# G. Переместить в начало

Вам дан массив a1 = 1, a2 = 2, ..., an = n и последовальность операций: переместить элементы с li по ri в начало массива. Например, для массива 2, 3, 6, 1, 5, 4, после операции (2, 4) новый порядок будет 3, 6, 1, 2, 5, 4. А после применения операции (3, 4) порядок элементов в массиве будет 1, 2, 3, 6, 5, 4.

Выведите порядок элементов в массиве после выполнения всех операций.

**Входные данные**

В первой строке входного файла указаны числа n и m (2 ≤ n ≤ 100 000, 1 ≤ m ≤ 100 000) — число элементов в массиве и число операций. Следующие m строк содержат операции в виде двух целых чисел: li и ri (1 ≤ li ≤ ri ≤ n).

**Выходные данные**

Выведите n целых чисел — порядок элементов в массиве после применения всех операций.

# H. Различные буквы

Вы работаете со списком из строчных латинских букв. Изначально список пуст. Вы должны поддерживать следующие операции:

insert index number letter — добавить number букв letter перед буквой с индексом index.
remove index number — удалить number букв, начиная с индекса index.
query index_1 index_2 — вывести количество различных букв на отрезке с index_1 до index_2 включительно.
Буквы нумеруются с 1.

**Входные данные**

В первой строке входного файла содержится единственное целое число n — количество операций (1 ≤ n ≤ 30 000). Следующие по n строк содержат описание операций.

Описание операции начинается с типа операции: '+' для добавления, '-' для удаления и '?' для запроса. Дальше следует аргументы запроса, описанные в условиях выше.

Все запросы корректны, элементы с такими индексами существуют, нет запросов на удаление несуществующих элементов.

number добавления, удаления не превышает 10 000.

**Выходные данные**

Для каждого запроса query выведите одно целое число — количество различных букв на отрезке index_1, index_2 включительно.

# I. Эх, дороги

В многострадальном Тридесятом государстве опять готовится дорожная реформа. Впрочем, надо признать, дороги в этом государстве находятся в довольно плачевном состоянии. Так что реформа не повредит. Одна проблема — дорожникам не развернуться, поскольку в стране действует жесткий закон — из каждого города должно вести не более двух дорог. Все дороги в государстве двусторонние, то есть по ним разрешено движение в обоих направлениях (разумеется, разметка отсутствует). В результате реформы некоторые дороги будут строиться, а некоторые другие закрываться на бессрочный ремонт.

Петя работает диспетчером в службе грузоперевозок на дальние расстояния. В связи с предстоящими реформами, ему необходимо оперативно определять оптимальные маршруты между городами в условиях постоянно меняющейся дорожной ситуации. В силу большого количества пробок и сотрудников дорожной полиции в городах, критерием оптимальности маршрута считается количество промежуточных городов, которые необходимо проехать.

Помогите Пете по заданной последовательности сообщений об изменении структуры дорог и запросам об оптимальном способе проезда из одного города в другой, оперативно отвечать на запросы.

**Входные данные**

В первой строке входного файла заданы числа n — количество городов, m — количество дорог в начале реформы и q — количество сообщений об изменении дорожной структуры и запросов (1 ≤ n, m ≤ 100 000, q ≤ 200 000). Следующие m строк содержат по два целых числа каждая — пары городов, соединенных дорогами перед реформой. Следующие q строк содержат по три элемента, разделенных пробелами. «+ i j» означает строительство дороги от города i до города j, «- i j» означает закрытие дороги от города i до города j, «? i j» означает запрос об оптимальном пути между городами i и j.

Гарантируется, что в начале и после каждого изменения никакие два города не соединены более чем одной дорогой, и из каждого города выходит не более двух дорог. Никакой город не соединяется дорогой сам с собой.

**Выходные данные**

На каждый запрос вида «? i j» выведите одно число — минимальное количество промежуточных городов на маршруте из города i в город j. Если проехать из i в j невозможно, выведите  - 1.

